use std::env;

fn p1() {
    // If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    // Find the sum of all the multiples of 3 or 5 below 1000.

    let mut sum = 0;
    for i in 0..1000 {
        if i % 5 == 0 || i % 3 == 0 {
            sum += i
        } 
    }
    println!("A1: {}", sum);
}

fn p2() {
    // Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    // 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    // By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    
    let mut prev_prev = 1;
    let mut prev = 2;
    let mut sum = 2;
    while prev < 4000000 {
        let tmp = prev;
        prev = prev_prev + prev;
        prev_prev = tmp;
        if prev % 2 == 0 {
            sum += prev
        }
    }
    println!("A2: {}", sum);

}

fn get_primes_up_to(n : usize) -> Vec<bool>  {
    // the sieve of eratosthenes
    let n = n as f32;
    let n_primes_guess = n.sqrt().ceil() as usize;
    let mut primes = vec![true; n_primes_guess];
    primes[0] = false;
    primes[1] = false;
    for i in 0..n_primes_guess {
        if i * i > n_primes_guess {
            break;
        }
        if primes[i] {
            // rust doesnt have the regular for loop and i dont
            // know how to increment by a number other than 1 nicely
            // i want: for(j = i*i; j < n_primes_guess; j += i)
            let mut j = i*i;
            while j < n_primes_guess {
                primes[j] = false;
                j = j + i;
            }
        }
    }
    return primes;
}

fn p3() {
    // The prime factors of 13195 are 5, 7, 13 and 29.
    // What is the largest prime factor of the number 600851475143 ?

    //let big_num = 13195 as usize;
    let big_num = 600851475143 as usize;
    //println!("primes: ");
    let primes = get_primes_up_to(big_num);
    //for (i,p) in primes.iter().enumerate() {
    //    println!("{}:{}", i, p) 
    //}
    let mut winner = 0;
    for (i,p) in primes.iter().enumerate() {
        if *p && big_num % i == 0 {
            winner = i
        }
    }
    println!("A3: {}", winner);
}

fn is_palindromic(n: usize) -> bool {
    let s = n.to_string().into_bytes();
    let n_digits = s.len();
    for i in 0..n_digits/2 {
        let left = s[i];
        let right = s[n_digits-i-1];
        if left != right {
            return false;
        }
    }
    return true;
}

fn find_largest_palindrom_prod_of_2_less_than(n: usize) -> usize {
    let mut winner = 0;
    for i in 0..n {
        for j in 0..n {
            if i * j > winner {
                if is_palindromic(i*j) {
                    winner = i * j;
                }
            }
        }
    }
    return winner;
}

fn p4() {
    // A palindromic number reads the same both ways. 
    // The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
    // Find the largest palindrome made from the product of two 3-digit numbers.

    //println!("is_palindromic(9009): {}", is_palindromic(9009));
    //println!("is_palindromic(9000): {}", is_palindromic(9000));
    //println!("A4: {}", find_largest_palindrom_prod_of_2_less_than(100));
    println!("A4: {}", find_largest_palindrom_prod_of_2_less_than(1000));
}

fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() < 2 {
        println!("specify a problem to solve");
        return;
    }
    match args[1].as_ref() {
        "1" => p1(),
        "2" => p2(),
        "3" => p3(),
        "4" => p4(),
        _ => println!("that's not a problem I recognize"),
    }
}
