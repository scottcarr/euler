use std::env;
use std::cmp;

fn p1() {
    // If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    // Find the sum of all the multiples of 3 or 5 below 1000.

    let mut sum = 0;
    for i in 0..1000 {
        if i % 5 == 0 || i % 3 == 0 {
            sum += i
        } 
    }
    println!("A1: {}", sum);
}

fn p2() {
    // Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    // 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    // By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    
    let mut prev_prev = 1;
    let mut prev = 2;
    let mut sum = 2;
    while prev < 4000000 {
        let tmp = prev;
        prev = prev_prev + prev;
        prev_prev = tmp;
        if prev % 2 == 0 {
            sum += prev
        }
    }
    println!("A2: {}", sum);

}

fn get_primes_up_to(n : usize) -> Vec<bool>  {
    // this guesses the the initial number wasn't prime
    // the sieve of eratosthenes
    let n = n as f32;
    let n_primes_guess = n.sqrt().ceil() as usize;
    let mut primes = vec![true; n_primes_guess];
    primes[0] = false;
    primes[1] = false;
    for i in 0..n_primes_guess {
        if i * i > n_primes_guess {
            break;
        }
        if primes[i] {
            // rust doesnt have the regular for loop and i dont
            // know how to increment by a number other than 1 nicely
            // i want: for(j = i*i; j < n_primes_guess; j += i)
            let mut j = i*i;
            while j < n_primes_guess {
                primes[j] = false;
                j = j + i;
            }
        }
    }
    return primes;
}

fn get_primes_up_to2(n : usize) -> Vec<bool>  {
    // the sieve of eratosthenes
    let n = n as f32;
    let n_primes_guess = n as usize;
    let mut primes = vec![true; n_primes_guess];
    primes[0] = false;
    primes[1] = false;
    for i in 0..n_primes_guess {
        if i * i > n_primes_guess {
            break;
        }
        if primes[i] {
            // rust doesnt have the regular for loop and i dont
            // know how to increment by a number other than 1 nicely
            // i want: for(j = i*i; j < n_primes_guess; j += i)
            let mut j = i*i;
            while j < n_primes_guess {
                primes[j] = false;
                j = j + i;
            }
        }
    }
    return primes;
}

fn p3() {
    // The prime factors of 13195 are 5, 7, 13 and 29.
    // What is the largest prime factor of the number 600851475143 ?

    //let big_num = 13195 as usize;
    let big_num = 600851475143 as usize;
    //println!("primes: ");
    let primes = get_primes_up_to(big_num);
    //for (i,p) in primes.iter().enumerate() {
    //    println!("{}:{}", i, p) 
    //}
    let mut winner = 0;
    for (i,p) in primes.iter().enumerate() {
        if *p && big_num % i == 0 {
            winner = i
        }
    }
    println!("A3: {}", winner);
}

fn is_palindromic(n: usize) -> bool {
    let s = n.to_string().into_bytes();
    let n_digits = s.len();
    for i in 0..n_digits/2 {
        let left = s[i];
        let right = s[n_digits-i-1];
        if left != right {
            return false;
        }
    }
    return true;
}

fn find_largest_palindrom_prod_of_2_less_than(n: usize) -> usize {
    let mut winner = 0;
    for i in 0..n {
        for j in 0..n {
            if i * j > winner {
                if is_palindromic(i*j) {
                    winner = i * j;
                }
            }
        }
    }
    return winner;
}

fn p4() {
    // A palindromic number reads the same both ways. 
    // The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
    // Find the largest palindrome made from the product of two 3-digit numbers.

    //println!("is_palindromic(9009): {}", is_palindromic(9009));
    //println!("is_palindromic(9000): {}", is_palindromic(9000));
    //println!("A4: {}", find_largest_palindrom_prod_of_2_less_than(100));
    println!("A4: {}", find_largest_palindrom_prod_of_2_less_than(1000));
}

fn is_divisible_by_all_up_to(number: usize, top: usize) -> bool {
    for i in 1..top {
        if number % i != 0 {
            return false;
        }
    }
    return true;
}

fn smallest_divisible_by_all(top: usize) -> usize {
    let mut i = top;
    loop {
        if is_divisible_by_all_up_to(i, top) {
            return i;
        }
        i += 1;
    }
}
fn p5() {
    // 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    // What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    
    println!("A5: {}", smallest_divisible_by_all(20));
}

fn p6() {
    //Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
    let mut sum_of_squares = 0;
    let mut sum = 0;
    for i in 1..101 {
        sum_of_squares += i*i;
        sum += i;
    }

    println!("A6: {}", sum*sum - sum_of_squares);
}

fn is_prime(n: usize) -> bool {
    let f = n as f64;
    let max = f.sqrt().ceil() as usize;
    for i in 2..max+1 {
        if n % i == 0 {
            return false;
        }
    }
    return true;
}

fn p7() {
    // By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    // What is the 10 001st prime number?
    
    let mut i = 2;
    let mut n_primes = 1;
    let mut prime = 2;
    let mut found = false;
    while !found {
        if is_prime(i) {
            if n_primes == 10001 - 1 {
                prime = i;
                found = true;
            }
            n_primes += 1;
        }
        i += 1;
    }
    
    println!("A7: {}", prime);
}

fn get_prod_starting_at(start: usize, num_digits: usize, number: &Vec<u32>) -> usize {
    let mut sum = 1 as usize;
    if start + num_digits >= number.len() {
        return 0;
    }
    for i in start..start+num_digits {
        sum *= number[i] as usize;
    }
    return sum;
}

fn find_greatest_streak(num_digits: usize, number: &Vec<u32>) -> usize {
    let mut winner = 0;
    for i in 0..number.len() {
        let tmp = get_prod_starting_at(i, num_digits, number);
        if tmp > winner {
            winner = tmp;
        }
    }
    return winner;
}

fn p8() {
    // The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

    // 73167176531330624919225119674426574742355349194934
    // 96983520312774506326239578318016984801869478851843
    // 85861560789112949495459501737958331952853208805511
    // 12540698747158523863050715693290963295227443043557
    // 66896648950445244523161731856403098711121722383113
    // 62229893423380308135336276614282806444486645238749
    // 30358907296290491560440772390713810515859307960866
    // 70172427121883998797908792274921901699720888093776
    // 65727333001053367881220235421809751254540594752243
    // 52584907711670556013604839586446706324415722155397
    // 53697817977846174064955149290862569321978468622482
    // 83972241375657056057490261407972968652414535100474
    // 82166370484403199890008895243450658541227588666881
    // 16427171479924442928230863465674813919123162824586
    // 17866458359124566529476545682848912883142607690042
    // 24219022671055626321111109370544217506941658960408
    // 07198403850962455444362981230987879927244284909188
    // 84580156166097919133875499200524063689912560717606
    // 05886116467109405077541002256983155200055935729725
    // 71636269561882670428252483600823257530420752963450
    // 
    // Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
    
    let number_str = "
    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450
    ";

    let number = number_str.chars().filter_map(|x| x.to_digit(10)).collect();

    println!("A8: {}", find_greatest_streak(13, &number));
}

fn p9() {
    // A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
    //
    // a2 + b2 = c2
    // For example, 32 + 42 = 9 + 16 = 25 = 52.
    //
    // There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    // Find the product abc.

    for a in 1..1000 {
        for b in 1..1000 {
            let sum_lhs = (a*a + b*b) as f64;
            let c = sum_lhs.sqrt();
            if c == c.floor() {
                let c = c as usize;
                if a + b + c == 1000 {
                    println!("A9: {}", a * b * c);
                    return;
                }
            }
        }
    }

}

fn p10() {
    // The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    // Find the sum of all the primes below two million.

    let lim = 2000000;
    //let lim = 10;
    let x = get_primes_up_to2(lim);
    let mut sum = 0;
    for (i, is_prime) in x.iter().enumerate() {
        println!("{}:{}", i, *is_prime);
        if *is_prime {
            sum += i;
        }
    }
    println!("A10: {}", sum);
}

struct SquareMatrix {
    data: Vec<u8>,
    n : usize,
}

impl SquareMatrix {
    fn at(&self, row: usize, col: usize) -> usize {
        return self.data[row*self.n+col] as usize;
    }
    fn is_start_of_valid_horz_4(&self, row: usize, col: usize) -> bool {
        return col + 3 < self.n && row < self.n;
    }
    fn is_start_of_valid_vert_4(&self, row: usize, col: usize) -> bool {
        return row + 3 < self.n && col < self.n;
    }
    fn is_start_of_valid_right_diag_4(&self, row: usize, col: usize) -> bool {
        return col + 3 < self.n && row + 3 < self.n;
    }
    fn is_start_of_valid_left_diag_4(&self, row: usize, col: usize) -> bool {
        return col >= 3 && col - 3 < self.n && row + 3 < self.n;
    }
    fn get_right_diag_4_prod(&self, row: usize, col: usize) -> usize {
        let mut tot : usize = 1;
        for i in 0..4 {
            tot *= self.at(row + i, col + i);
        }
        println!("({}, {}) diag = {}", row, col, tot);
        return tot;
    }
    fn get_left_diag_4_prod(&self, row: usize, col: usize) -> usize {
        let mut tot : usize = 1;
        for i in 0..4 {
            tot *= self.at(row + i, col - i);
        }
        println!("({}, {}) diag = {}", row, col, tot);
        return tot;
    }
    fn get_horz_4_prod(&self, row: usize, col: usize) -> usize {
        let mut tot : usize = 1;
        for i in 0..4 {
            tot *= self.at(row, col + i);
        }
        println!("({}, {}) horz = {}", row, col, tot);
        return tot;
    }
    fn get_vert_4_prod(&self, row: usize, col: usize) -> usize {
        let mut tot : usize = 1;
        for i in 0..4 {
            tot *= self.at(row + i, col);
        }
        println!("({}, {}) down = {}", row, col, tot);
        return tot;
    }

}

fn p11() {
    // What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
    let d = vec!(
08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08,
49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00,
81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65,
52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91,
22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80,
24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50,
32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70,
67,26,20,68,02,62,12,20,95,63,94,39,63,08,40,91,66,49,94,21,
24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72,
21,36,23,09,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95,
78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,09,53,56,92,
16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57,
86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58,
19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40,
04,52,08,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66,
88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69,
04,42,16,73,38,25,39,11,24,94,72,18,08,46,29,32,40,62,76,36,
20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16,
20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54,
01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48
);
    let m = SquareMatrix {data : d, n : 20};
    let mut winner : usize = 0;
    for i in 0..20 {
        for j in 0..20 {
            if m.is_start_of_valid_vert_4(i,j) {
                let x = m.get_vert_4_prod(i,j);
                winner = cmp::max(x, winner);
            }
            if m.is_start_of_valid_left_diag_4(i,j) {
                let x = m.get_left_diag_4_prod(i,j);
                winner = cmp::max(x, winner);
            }
            if m.is_start_of_valid_right_diag_4(i,j) {
                let x = m.get_right_diag_4_prod(i,j);
                winner = cmp::max(x, winner);
            }
            if m.is_start_of_valid_horz_4(i,j) {
                let x = m.get_horz_4_prod(i,j);
                winner = cmp::max(x, winner);
            }
        }
    }
    println!("A11: {}", winner);
    //println!("{}", m.get_diag_4_prod(6,8));
}

//fn get_smallest_divisor(n: usize) -> usize {
//    if n == 1 { return 1; }
//    if n == 2 { return 2; }
//    for i in 2..n {
//        if n % i == 0 {
//            return i;
//        }
//    }
//    return n;
//}
//
//fn get_divisors(n: usize) -> Vec<usize> {
//    let mut vec = Vec::new();
//    vec.push(1);
//    let mut curr = n;
//    while curr != 1 {
//        let div = get_smallest_divisor(curr);
//        vec.push(div);
//        curr = curr / div;
//    }
//    vec.push(n);
//    vec
//}

fn get_all_divisors(n: usize) -> Vec<usize> {
    let mut vec = Vec::new();
    let n_float = n as f64;
    vec.push(1);
    for i in 2..n {
        let i_float = i as f64;
        let res = n_float / i_float;
        if res == res.ceil() {
            vec.push(i);
        }
    }
    vec.push(n);
    vec
}

fn p12() {
    //  The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    //  
    //  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    //  
    //  Let us list the factors of the first seven triangle numbers:
    //  
    //       1: 1
    //       3: 1,3
    //       6: 1,2,3,6
    //      10: 1,2,5,10
    //      15: 1,3,5,15
    //      21: 1,3,7,21
    //      28: 1,2,4,7,14,28
    //  
    //  We can see that 28 is the first triangle number to have over five divisors.
    //  
    //  What is the value of the first triangle number to have over five hundred divisors?

    //println!("div(6): ");
    //let divs = get_all_divisors(6);
    //for d in divs.iter() {
    //    println!("{}", d);
    //}
    //println!("div(10): ");
    //let divs = get_all_divisors(10);
    //for d in divs.iter() {
    //    println!("{}", d);
    //}
    //println!("div(28): ");
    //let divs = get_all_divisors(28);
    //for d in divs.iter() {
    //    println!("{}", d);
    //}
    
    let mut vec = Vec::new();
    let mut tri = 0;
    let mut i = 1;
    while (vec.size() <= 500) {
        tri += i;
        vec = get_all_divisors(tri);
        i += 1;
    }
    println("A12: {}", tri);

}

fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() < 2 {
        println!("specify a problem to solve");
        return;
    }
    match args[1].as_ref() {
        "1" => p1(),
        "2" => p2(),
        "3" => p3(),
        "4" => p4(),
        "5" => p5(),
        "6" => p6(),
        "7" => p7(),
        "8" => p8(),
        "9" => p9(),
        "10" => p10(),
        "11" => p11(),
        "12" => p12(),
        _ => println!("that's not a problem I recognize"),
    }
}
