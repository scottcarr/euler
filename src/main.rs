use std::env;

fn p1() {
    // If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    // Find the sum of all the multiples of 3 or 5 below 1000.

    let mut sum = 0;
    for i in 0..1000 {
        if i % 5 == 0 || i % 3 == 0 {
            sum += i
        } 
    }
    println!("A1: {}", sum);
}

fn p2() {
    // Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    // 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    // By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    
    let mut prev_prev = 1;
    let mut prev = 2;
    let mut sum = 2;
    while prev < 4000000 {
        let tmp = prev;
        prev = prev_prev + prev;
        prev_prev = tmp;
        if prev % 2 == 0 {
            sum += prev
        }
    }
    println!("A2: {}", sum);

}

fn get_primes_up_to(n : usize) -> Vec<bool>  {
    // the sieve of eratosthenes
    let n = n as f32;
    let n_primes_guess = n.sqrt().ceil() as usize;
    let mut primes = vec![true; n_primes_guess];
    primes[0] = false;
    primes[1] = false;
    for i in 0..n_primes_guess {
        if i * i > n_primes_guess {
            break;
        }
        if primes[i] {
            // rust doesnt have the regular for loop and i dont
            // know how to increment by a number other than 1 nicely
            // i want: for(j = i*i; j < n_primes_guess; j += i)
            let mut j = i*i;
            while j < n_primes_guess {
                primes[j] = false;
                j = j + i;
            }
        }
    }
    return primes;
}

fn p3() {
    // The prime factors of 13195 are 5, 7, 13 and 29.
    // What is the largest prime factor of the number 600851475143 ?

    //let big_num = 13195 as usize;
    let big_num = 600851475143 as usize;
    //println!("primes: ");
    let primes = get_primes_up_to(big_num);
    //for (i,p) in primes.iter().enumerate() {
    //    println!("{}:{}", i, p) 
    //}
    let mut winner = 0;
    for (i,p) in primes.iter().enumerate() {
        if *p && big_num % i == 0 {
            winner = i
        }
    }
    println!("A3: {}", winner);
}

fn is_palindromic(n: usize) -> bool {
    let s = n.to_string().into_bytes();
    let n_digits = s.len();
    for i in 0..n_digits/2 {
        let left = s[i];
        let right = s[n_digits-i-1];
        if left != right {
            return false;
        }
    }
    return true;
}

fn find_largest_palindrom_prod_of_2_less_than(n: usize) -> usize {
    let mut winner = 0;
    for i in 0..n {
        for j in 0..n {
            if i * j > winner {
                if is_palindromic(i*j) {
                    winner = i * j;
                }
            }
        }
    }
    return winner;
}

fn p4() {
    // A palindromic number reads the same both ways. 
    // The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
    // Find the largest palindrome made from the product of two 3-digit numbers.

    //println!("is_palindromic(9009): {}", is_palindromic(9009));
    //println!("is_palindromic(9000): {}", is_palindromic(9000));
    //println!("A4: {}", find_largest_palindrom_prod_of_2_less_than(100));
    println!("A4: {}", find_largest_palindrom_prod_of_2_less_than(1000));
}

fn is_divisible_by_all_up_to(number: usize, top: usize) -> bool {
    for i in 1..top {
        if number % i != 0 {
            return false;
        }
    }
    return true;
}

fn smallest_divisible_by_all(top: usize) -> usize {
    let mut i = top;
    loop {
        if is_divisible_by_all_up_to(i, top) {
            return i;
        }
        i += 1;
    }
}
fn p5() {
    // 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    // What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    
    println!("A5: {}", smallest_divisible_by_all(20));
}

fn p6() {
    //Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
    let mut sum_of_squares = 0;
    let mut sum = 0;
    for i in 1..101 {
        sum_of_squares += i*i;
        sum += i;
    }

    println!("A6: {}", sum*sum - sum_of_squares);
}

fn is_prime(n: usize) -> bool {
    let f = n as f64;
    let max = f.sqrt().ceil() as usize;
    for i in 2..max+1 {
        if n % i == 0 {
            return false;
        }
    }
    return true;
}

fn p7() {
    // By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    // What is the 10 001st prime number?
    
    let mut i = 2;
    let mut n_primes = 1;
    let mut prime = 2;
    let mut found = false;
    while !found {
        if is_prime(i) {
            if n_primes == 10001 - 1 {
                prime = i;
                found = true;
            }
            n_primes += 1;
        }
        i += 1;
    }
    
    println!("A7: {}", prime);
}

fn get_prod_starting_at(start: usize, num_digits: usize, number: &Vec<u32>) -> usize {
    let mut sum = 1 as usize;
    if start + num_digits >= number.len() {
        return 0;
    }
    for i in start..start+num_digits {
        sum *= number[i] as usize;
    }
    return sum;
}

fn find_greatest_streak(num_digits: usize, number: &Vec<u32>) -> usize {
    let mut winner = 0;
    for i in 0..number.len() {
        let tmp = get_prod_starting_at(i, num_digits, number);
        if tmp > winner {
            winner = tmp;
        }
    }
    return winner;
}

fn p8() {
    // The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

    // 73167176531330624919225119674426574742355349194934
    // 96983520312774506326239578318016984801869478851843
    // 85861560789112949495459501737958331952853208805511
    // 12540698747158523863050715693290963295227443043557
    // 66896648950445244523161731856403098711121722383113
    // 62229893423380308135336276614282806444486645238749
    // 30358907296290491560440772390713810515859307960866
    // 70172427121883998797908792274921901699720888093776
    // 65727333001053367881220235421809751254540594752243
    // 52584907711670556013604839586446706324415722155397
    // 53697817977846174064955149290862569321978468622482
    // 83972241375657056057490261407972968652414535100474
    // 82166370484403199890008895243450658541227588666881
    // 16427171479924442928230863465674813919123162824586
    // 17866458359124566529476545682848912883142607690042
    // 24219022671055626321111109370544217506941658960408
    // 07198403850962455444362981230987879927244284909188
    // 84580156166097919133875499200524063689912560717606
    // 05886116467109405077541002256983155200055935729725
    // 71636269561882670428252483600823257530420752963450
    // 
    // Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
    
    let number_str = "
    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450
    ";

    let number = number_str.chars().filter_map(|x| x.to_digit(10)).collect();

    println!("A8: {}", find_greatest_streak(13, &number));
}

fn p9() {
    // A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
    //
    // a2 + b2 = c2
    // For example, 32 + 42 = 9 + 16 = 25 = 52.
    //
    // There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    // Find the product abc.

    for a in 1..1000 {
        for b in 1..1000 {
            let sum_lhs = (a*a + b*b) as f64;
            let c = sum_lhs.sqrt();
            if c == c.floor() {
                let c = c as usize;
                if a + b + c == 1000 {
                    println!("A9: {}", a * b * c);
                    return;
                }
            }
        }
    }

}

fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() < 2 {
        println!("specify a problem to solve");
        return;
    }
    match args[1].as_ref() {
        "1" => p1(),
        "2" => p2(),
        "3" => p3(),
        "4" => p4(),
        "5" => p5(),
        "6" => p6(),
        "7" => p7(),
        "8" => p8(),
        "9" => p9(),
        _ => println!("that's not a problem I recognize"),
    }
}
